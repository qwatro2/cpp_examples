Класс std::string (которым пользоваться все еще пока запрещено) в большинстве случаев удобнее в использовании, безопаснее и иногда эффективнее C-style строк. Однако бывают ситуации, в которых использование последних гораздо предпочтительнее. Например, обращение к элементам строки это всегда (ну, или [почти всегда](https://blogs.msmvps.com/gdicanio/2016/11/17/the-small-string-optimization/)) обращение к памяти в куче, что требует некоторых накладных расходов. Также часто приходится заводить константные строки со статическим временем жизни (обозначение допустимых команд принимаемых программой и т.п.) и для каждой из них необходимо вызвать конструктор, выделить память в куче, заполнить... В то время как строковые литералы заводятся в статической области памяти еще до начала выполнения программы. А если глобальный (статический) объект std::string бросит исключение при создании? Тогда его нельзя будет обработать и программа аварийно завершится, так толком и не начав работать.

Хорошо, давайте в этих ситуациях использовать const char*. Но это же снова strlen, работающий за линейное время, strcmp вместо операторов сравнения, небезопасный доступ к данным...

В C++17 появился класс std::string_view, который является легковесной оберткой над C строками. Все, что он хранит,- это указатель на константную последовательность символов и ее размер. Для доступа и работы с ней используются интуитивно понятные методы без необходимости задумываться о завершающем нулевом символе. Более того, последовательность символов не обязана быть нуль-терминированной, так как размер строки хранится в отдельном поле. Таким образом, мы нивелируем недостатки const char*, в полной мере используя его преимущества.